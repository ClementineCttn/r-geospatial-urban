---
title: "Introduction to visualisation"

---

:::::::::::::::::::::::::::::::::::::: questions 

- How can I create a basic plot in R?
- How can I add features to a plot?
- How can I get basic summary information about my data set?
- How can I include addition information via a colours palette. 
- How can I find more information about a function and its arguments? 
- How can I create new columns or remove existing columns from a data frame?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Generate plots to visualise data with ggplot.
- Add plot layers to incrementally build a more complex plot.
- Use the 'fill' argument for coloring surfaces, and modify colours with the  viridis or scale_manual packages. 
- Explore the help documentation.
- Save and format your plot via the ggsave function.  

::::::::::::::::::::::::::::::::::::::::::::::::

# [Introduction to Visualisation](https://datacarpentry.org/r-intro-geospatial/07-plot-ggplot2/index.html)

Package `ggplot2` is a powerful plotting system. I will introduce key
features of `ggplot`. In the following parts of this workshop, you will
use this package to visualize geo-spatial data. `gg` stands for grammar
of graphics, the idea that three components needed to create a graph
are: - data - aesthetics - coordinate system on which we map the data
(what is represented on x axis, what on y axis) - geometries - visual
representation of the data (points, bars, etc.)

Fun part about `ggplot` is that you can then add additional layers to
the plot providing more information and make it more beautiful.

First, lets plot distribution of life expectancy in the `gapminder` data
set.

```{r ggplot}
  ggplot(data = gapminder,  aes(x = lifeExp) ) + # aesthetics layer 
  geom_histogram() # geometry layer

```

You can see that in `ggplot` you use `+` as a pipe, to add layers.
Within `ggplot` call, it is the only pipe that will work. But, it is
possible to chain operations on a data set with a pipe that we have
already learned: `%>%` ( or `|>`) and follow them by ggplot grammar.

Let's create another plot, this time only on a subset of observations:

```{r ggplot-col}
gapminder %>%  # we select a data set
  filter(year == 2007 & 
         continent == 'Americas') %>% # and filter it to keep only one year and one continent
  ggplot(aes(x = country, y = gdpPercap)) + # we create aesthetics, both x and y axis represent values of  columns
  geom_col() # we select a column graph as a geometry
```

Now, you can iteratively improve how the plot looks like. For example,
you might want to flip it, to better display the labels.

```{r ggplot-coord-flip}
gapminder %>%  
  filter(year == 2007, 
         continent == 'Americas') %>% 
  ggplot(aes(x = country, y = gdpPercap)) + 
  geom_col()+ 
  coord_flip()
```

One thing you might want to change here is the order in which countries
are displayed. It would be easier to compare GDP per capita, if they
were showed in order. To do that, we need to reorder factor levels (you
remember, we've already done this before).

Now the order of the levels will depend on another variable - GDP per
capita.

```{r ggplot-color}
gapminder %>%  
  filter(year == 2007, 
         continent == 'Americas') %>% 
  mutate(country = fct_reorder(country, gdpPercap )) %>%
  ggplot(aes(x = country , y = gdpPercap)) + 
  geom_col() +
  coord_flip()

```

Let's make things more colorful - let's represent the average life
expectancy of a country by color

```{r ggplot-colors}
gapminder %>%  
  filter(year == 2007, 
         continent == 'Americas') %>% 
  mutate(country = fct_reorder(country, gdpPercap )) %>%
  ggplot(aes(x = country, y = gdpPercap, fill = lifeExp  )) + # fill argument for coloring surfaces, color for points and lines
  geom_col()+ 
  coord_flip()


```

We can also adapt the color scale. Common choice that is used for its
readibility and colorblind-proofness are the pallettes available in the
`viridis` package.

```{r ggplot-colors-adapt}
gapminder %>%  
  filter(year == 2007, 
         continent == 'Americas') %>% 
  mutate(country = fct_reorder(country, gdpPercap )) %>%
  ggplot(aes(x = country, y = gdpPercap, fill = lifeExp   )) + 
  geom_col()+ 
  coord_flip()+
  scale_fill_viridis_c() # _c stands for continuous scale 

```

Maybe we don't need that much information about the life expectancy. We
only want to know if it's below or above average.

```{r ggplot-colors-discrete}
plot_d <-  # this time let's save the plot in the object.
  gapminder %>%  
  filter(year == 2007 & 
         continent == 'Americas') %>% 
  mutate(country = fct_reorder(country, gdpPercap ),
         lifeExpCat = if_else(lifeExp >= mean(lifeExp), 'high', 'low' )
         ) %>%
  ggplot(aes(x = country, y = gdpPercap, fill = lifeExpCat)) + 
  geom_col()+ 
  coord_flip()+
  scale_fill_manual(values = c('light blue', 'orange')) 

```

Since we saved a plot as an object, nothing has been printed out. Just
like with any other object in `R`, if you want to see it, you need to
call it.

```{r ggplot-call}
plot_d

```

Now we can make use of the saved object and add things to it.

Let's also give it a title and name the axes:

```{r ggplot-titles}
plot_d <- 
  plot_d +
  ggtitle('GDP per capita in Americas', subtitle = 'Year 2007') +
  xlab('Country')+
  ylab('GDP per capita')

plot_d
```

# [Writing data](https://datacarpentry.org/r-intro-geospatial/08-writing-data/index.html)

## Saving the plot

Once we are happy with our plot we can save it in a format of our
choice. Remember to save it in the dedicated folder.

```{r save-plot}
ggsave(plot = plot_d, 
       filename = here('fig_output','plot_americas_2007.pdf') ) # By default, ggsave() saves the last displayed plot, but you can also explicitly name the plot you want to save

```

### Using help documentation

My saved plot is not very readable. We can see why it happened by
exploring the help documentation. We can do it by writing directly in
the Console:

```{r help, eval=FALSE}
?ggsave
```

We can read that it uses the "size of the current graphics device". That
would explain why our saved plots look slightly different. Feel free to
explore the documentation to see how to adapt the size e.g. by adapting
`width`, `height` and `units` parameter.

## Saving the data

Another output of your work you want to save is a cleaned data set. In
your analysis, you can then load directly that data set. Say we want to
save the data only for Australia:

```{r writing-data}
gapminder_amr_2007 <- gapminder %>%
  filter(year == 2007 & continent == 'Americas') %>%
  mutate(country_reordered = fct_reorder(country, gdpPercap ), 
         lifeExpCat = if_else(lifeExp >= mean(lifeExp), 'high', 'low'))

write.csv(gapminder_amr_2007, here('data_output', 'gapminder_americas_2007.csv'), row.names=FALSE)
```
